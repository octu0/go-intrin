package x86

import (
	"reflect"
	"testing"
	"unsafe"
)

func TestInt32Add(t *testing.T) {
	out := Int32Add(
		[8]int32{1, -2, 3, 400, 255, 161, 777, 888},
		[8]int32{1, 3, -5, 488, 255, 505, 777, 888},
	)
	expect := [8]int32{
		2, 1, -2, 888, 510, 666, 1554, 1776,
	}
	if reflect.DeepEqual(expect, out) != true {
		t.Errorf("expect %v <> actual %v", expect, out)
	}
}

func TestInt32Sub(t *testing.T) {
	out := Int32Sub(
		[8]int32{1, 2, -3, 400, 255, 161, 777, 888},
		[8]int32{2, -3, 5, 488, 255, 505, 177, 1088},
	)
	expect := [8]int32{
		-1, 5, -8, -88, 0, -344, 600, -200,
	}
	if reflect.DeepEqual(expect, out) != true {
		t.Errorf("expect %v <> actual %v", expect, out)
	}
}

func TestInt32Abs(t *testing.T) {
	out := Int32Abs(
		[8]int32{1, -2, -3, -100, -255, 1024, 777, -888},
	)
	expect := [8]int32{
		1, 2, 3, 100, 255, 1024, 777, 888,
	}
	if reflect.DeepEqual(expect, out) != true {
		t.Errorf("expect %v <> actual %v", expect, out)
	}
}

func TestInt32And(t *testing.T) {
	ua := [8]uint32{
		0b10000000_00000000_00000000_00000000,
		0b10000000_10000000_00000000_00000000,
		0b10000000_10000000_10000000_00000000,
		0b10000000_10000000_10000000_10000000,
		0b00000000_10000000_00000000_00000000,
		0b00000000_00000000_10000000_00000000,
		0b00000000_00000000_00000000_10000000,
		0b00000000_00000000_00000000_00000000,
	}
	ub := [8]uint32{
		0b11111111_00000000_00000000_00000000,
		0b11111111_11111111_00000000_00000000,
		0b11111111_11111111_11111111_00000000,
		0b11111111_11111111_11111111_11111111,
		0b00000000_11111111_00000000_00000000,
		0b00000000_00000000_11111111_00000000,
		0b00000000_00000000_00000000_11111111,
		0b00000001_00000001_00000001_00000001,
	}
	ue := [8]uint32{
		0b10000000_00000000_00000000_00000000,
		0b10000000_10000000_00000000_00000000,
		0b10000000_10000000_10000000_00000000,
		0b10000000_10000000_10000000_10000000,
		0b00000000_10000000_00000000_00000000,
		0b00000000_00000000_10000000_00000000,
		0b00000000_00000000_00000000_10000000,
		0b00000000_00000000_00000000_00000000,
	}

	a := *(*[8]int32)(unsafe.Pointer(&ua[0]))
	b := *(*[8]int32)(unsafe.Pointer(&ub[0]))
	e := *(*[8]int32)(unsafe.Pointer(&ue[0]))

	out := Int32And(a, b)
	if reflect.DeepEqual(e, out) != true {
		t.Errorf("expect %v <> actual %v", e, out)
	}
}

func TestInt32Or(t *testing.T) {
	ua := [8]uint32{
		0b10000000_00000000_00000000_00000000,
		0b10000000_10000000_00000000_00000000,
		0b10000000_10000000_10000000_00000000,
		0b10000000_10000000_10000000_10000000,
		0b00000000_10000000_00000000_00000000,
		0b00000000_00000000_10000000_00000000,
		0b00000000_00000000_00000000_10000000,
		0b00000000_00000000_00000000_00000000,
	}
	ub := [8]uint32{
		0b11111111_00000000_00000000_00000000,
		0b11111111_11111111_00000000_00000000,
		0b11111111_11111111_11111111_00000000,
		0b11111111_11111111_11111111_11111111,
		0b00000000_11111111_00000000_00000000,
		0b00000000_00000000_11111111_00000000,
		0b00000000_00000000_00000000_11111111,
		0b00000001_00000001_00000001_00000001,
	}
	ue := [8]uint32{
		0b11111111_00000000_00000000_00000000,
		0b11111111_11111111_00000000_00000000,
		0b11111111_11111111_11111111_00000000,
		0b11111111_11111111_11111111_11111111,
		0b00000000_11111111_00000000_00000000,
		0b00000000_00000000_11111111_00000000,
		0b00000000_00000000_00000000_11111111,
		0b00000001_00000001_00000001_00000001,
	}

	a := *(*[8]int32)(unsafe.Pointer(&ua[0]))
	b := *(*[8]int32)(unsafe.Pointer(&ub[0]))
	e := *(*[8]int32)(unsafe.Pointer(&ue[0]))

	out := Int32Or(a, b)
	if reflect.DeepEqual(e, out) != true {
		t.Errorf("expect %v <> actual %v", e, out)
	}
}

func TestInt32Xor(t *testing.T) {
	ua := [8]uint32{
		0b10000000_00000000_00000000_00000000,
		0b10000000_10000000_00000000_00000000,
		0b10000000_10000000_10000000_00000000,
		0b10000000_10000000_10000000_10000000,
		0b00000000_10000000_00000000_00000000,
		0b00000000_00000000_10000000_00000000,
		0b00000000_00000000_00000000_10000000,
		0b00000000_00000000_00000000_00000000,
	}
	ub := [8]uint32{
		0b11111111_00000000_00000000_00000000,
		0b11111111_11111111_00000000_00000000,
		0b11111111_11111111_11111111_00000000,
		0b11111111_11111111_11111111_11111111,
		0b00000000_11111111_00000000_00000000,
		0b00000000_00000000_11111111_00000000,
		0b00000000_00000000_00000000_11111111,
		0b00000001_00000001_00000001_00000001,
	}
	ue := [8]uint32{
		0b01111111_00000000_00000000_00000000,
		0b01111111_01111111_00000000_00000000,
		0b01111111_01111111_01111111_00000000,
		0b01111111_01111111_01111111_01111111,
		0b00000000_01111111_00000000_00000000,
		0b00000000_00000000_01111111_00000000,
		0b00000000_00000000_00000000_01111111,
		0b00000001_00000001_00000001_00000001,
	}

	a := *(*[8]int32)(unsafe.Pointer(&ua[0]))
	b := *(*[8]int32)(unsafe.Pointer(&ub[0]))
	e := *(*[8]int32)(unsafe.Pointer(&ue[0]))

	out := Int32Xor(a, b)
	if reflect.DeepEqual(e, out) != true {
		t.Errorf("expect %v <> actual %v", e, out)
	}
}

func TestInt32AndNot(t *testing.T) {
	ua := [8]uint32{
		0b00000000_10000000_00000000_00000000,
		0b01100000_10000000_00000000_00000000,
		0,
		0b01000000_11001000_00000000_00000010,
		0b00000000_10000000_00000000_00000000,
		0b00000000_10000000_00000000_00000000,
		0b00000000_10000000_00000000_00000000,
		0b00000000_10000000_00000000_00000000,
	}
	ub := [8]uint32{
		0b00000001_10000000_00000000_00000000,
		0b01000001_10000000_00000000_00000000,
		0,
		0b01000000_01111000_00000000_00000000,
		0b00000001_11000000_00000000_00000000,
		0b00000001_11100000_00000000_00000000,
		0b00000001_11110000_00000000_00000000,
		0b00000001_10100000_00000000_00000000,
	}
	ue := [8]uint32{
		0b00000001_00000000_00000000_00000000,
		0b00000001_00000000_00000000_00000000,
		0,
		0b00000000_00110000_00000000_00000000,
		0b00000001_01000000_00000000_00000000,
		0b00000001_01100000_00000000_00000000,
		0b00000001_01110000_00000000_00000000,
		0b00000001_00100000_00000000_00000000,
	}

	a := *(*[8]int32)(unsafe.Pointer(&ua[0]))
	b := *(*[8]int32)(unsafe.Pointer(&ub[0]))
	e := *(*[8]int32)(unsafe.Pointer(&ue[0]))

	out := Int32AndNot(a, b)
	if reflect.DeepEqual(e, out) != true {
		t.Errorf("expect %v <> actual %v", e, out)
	}
}

func TestInt32ToFloat32(t *testing.T) {
	t.Run("m128", func(tt *testing.T) {
		out := int32ToFloat32M128([]int32{100, -100, 32767, 65535, 123456})
		expect := []float32{
			100.0, -100.0, 32767.0, 65535.0, 123456.0,
		}
		if reflect.DeepEqual(expect, out) != true {
			tt.Errorf("expect %v <> actual %v", expect, out)
		}
	})
	t.Run("m256", func(tt *testing.T) {
		out := int32ToFloat32M256([]int32{100, -100, 32767, 65535, 123456})
		expect := []float32{
			100.0, -100.0, 32767.0, 65535.0, 123456.0,
		}
		if reflect.DeepEqual(expect, out) != true {
			tt.Errorf("expect %v <> actual %v", expect, out)
		}
	})
}

func TestFloat32ToInt32(t *testing.T) {
	t.Run("m128", func(tt *testing.T) {
		out := float32ToInt32M128([]float32{100.0, -100.0, 32767.0, 65535.0, 0.12345})
		expect := []int32{
			100, -100, 32767, 65535, 0,
		}
		if reflect.DeepEqual(expect, out) != true {
			tt.Errorf("expect %v <> actual %v", expect, out)
		}
	})
	t.Run("m256", func(tt *testing.T) {
		out := float32ToInt32M256([]float32{100.0, -100.0, 32767.0, 65535.0, 0.12345})
		expect := []int32{
			100, -100, 32767, 65535, 0,
		}
		if reflect.DeepEqual(expect, out) != true {
			tt.Errorf("expect %v <> actual %v", expect, out)
		}
	})
}

func TestInt32ToFloat64(t *testing.T) {
	t.Run("m128", func(tt *testing.T) {
		out := int32ToFloat64M128([]int32{100, -100, 2, 5})
		expect := []float64{100.0, -100.0, 2.0, 5.0}

		if reflect.DeepEqual(expect, out) != true {
			t.Errorf("expect %v <> actual %v", expect, out)
		}
	})
	t.Run("m256", func(tt *testing.T) {
		out := int32ToFloat64M256([]int32{100, -100, 2, 5})
		expect := []float64{100.0, -100.0, 2.0, 5.0}

		if reflect.DeepEqual(expect, out) != true {
			t.Errorf("expect %v <> actual %v", expect, out)
		}
	})
}

func TestFloat64ToInt32(t *testing.T) {
	t.Run("m128", func(tt *testing.T) {
		out := float64ToInt32M128([]float64{100.0, -100.0, 2.0, 5.0})
		expect := []int32{100, -100, 2, 5}

		if reflect.DeepEqual(expect, out) != true {
			t.Errorf("expect %v <> actual %v", expect, out)
		}
	})
	t.Run("m256", func(tt *testing.T) {
		out := float64ToInt32M256([]float64{100.0, -100.0, 2.0, 5.0})
		expect := []int32{100, -100, 2, 5}

		if reflect.DeepEqual(expect, out) != true {
			t.Errorf("expect %v <> actual %v", expect, out)
		}
	})
}
